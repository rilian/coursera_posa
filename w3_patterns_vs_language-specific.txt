Patterns name the recurring design structure and specify it explicitly by identifying key object roles and relationships, dependencies, interactions and conventions. They abstract from problem domain, form factor, vendor etc. Patterns "distill" knowledge from experts from their successful design experiences.

Thus, generally patterns are independent from programming language and implementation techniques. But, certain languages have their specific patterns (for example Destructor, ResourceAcquisition in C++, eager loading in Ruby) - they are called Idioms, and they usually take advantages of language-specific constructions and codifying style.
Both applying pattern-oriented solutions and language-specific solutions have their pros and cons. We can split it into several factors, or design dimensions:

Performance. It looks like obvious that applying language-specific techniques may dramatically increase certain middleware layer (application) speed. Adding to Destructor technique in C++ mentioned in lecture, for example in Javascript there is also a looping technique which goes through collection and destroys objects one by one and this works much more faster than pattern-oriented solution of looping through a collection of given size.

Portability. Here it is quite obvious that domain-independent pattern-oriented solution is highly portable (if given language has the specific features for solution), unlike the language-specific solution may be not portable at all. In this case developers have to extract the "pattern" from their solution and shift it to another language. This may cause additional time, costs, and require more experienced developers.

Maintainability. Both patterns and languages may win here. Patterns keep being maintainable while the architecture design keeps following the patterns or pattern sequences. And language-specific solution as well may be maintainable, and maybe provide additional extra speed, while there are available experienced developers to codify the given problem. Also we can note that in a "very long run" solution that utilises patterns and keeps the architecture consistent, usually is a win. This is generally specific to monstrous enterprise applications. The more unification and keeping convention, the better.

Time-to-market. This highly depend on the problem domain of application. A new startup prototype may extensively use the new and shiny language-specific solution (a blog in 15 minutes in Ruby on Rails). This allows quickly codify and release the version, ignoring even several of design dimensions. If the idea of startup "explode", developers gain time to build the solution that will use appropriate patterns and be scalable and maintainable. As for using patterns for application from scratch - developing proper architecture may take some time, which is not available in concurrent world. But if the market allows, and it is guaranteed that customers will use this new software, it makes much sense to build it properly from scratch. For example new OS versions or some popular software that is leader of market in their niche.


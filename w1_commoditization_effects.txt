I work as professional web software developer an of course commoditization has great impact on my work. as mentioned in the course lecture, first people invent a product, and after using it they think how to easily manage and control multiple such products. In my career i have the same experience, when being student, i wor mostly working on algorithms and programs that solve one particular issue, and at work i am solving issues with integration of different services that each solve a particular, completely different, task. Commoditization greatly helps because it allows to focus on the high-level business task, not digging into details. Of course, if you find the solution out of the shelf :).

Various frameworks and middleware layers, available out of the box, provide great opportunity to businesses and startups to build the prototype faster, try out the idea and so on. With constant drop of hardware prices and growth of available service speed, it became cost-effective to focus on building your unique product on top of available middleware stack, rather spend ages developing and testing own stack with the similar features. This is mostly true to small and middle-level companies, because the higher the load and distribution of service, the less middleware is available off the shelf. This one of the limitations and to solve it, companies have to do the in-house research and build custom solutions.

Another limitation is, middleware usually is not so independent and if you choose one layer, you have to use all dependent. For example common LAMP (Linux + Apache + mySQL + PHP) stack for web services. This bring the speed issue, like in this example PHP allows develop solutions much faster but it is slow and insecure. From the other hand you can build bullet-proof solution in C but will spend much more time. Speed issue is also sometimes named "middleware overhead", and sometimes it makes more sense to build custom solution or replace stack than constantly fight with performance issues of one given middleware of framework.

And another limitation is, the more unique is your middleware stack, the harder you can find professionals that are experienced in connecting and supporting it.

Common strategy in development of software is "no premature optimization", which leads to: take one set of middleware, you and your team most proficient in, build solution, and then optimize bottlenecks. Of course you have to think about consequences and not start building customer management system with MS Excel spreadsheet macros, but the idea is to balance the effectiveness of building software on given stack with proficiency of team.

Through my carrier i've learned to keep using as long as possible use 3rd-party software off the shelf, and focus on the implementation of business task atop of it, rather than deeping into development of custom low-level component. With open source software this brings feedback to the community and allows component developers better test and unify solutions, releasing more stable versions, which benefit all middleware users.

